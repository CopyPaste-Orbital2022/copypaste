// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'drawing_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DrawingState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DrawingStateCopyWith<$Res> {
  factory $DrawingStateCopyWith(
          DrawingState value, $Res Function(DrawingState) then) =
      _$DrawingStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$DrawingStateCopyWithImpl<$Res> implements $DrawingStateCopyWith<$Res> {
  _$DrawingStateCopyWithImpl(this._value, this._then);

  final DrawingState _value;
  // ignore: unused_field
  final $Res Function(DrawingState) _then;
}

/// @nodoc
abstract class _$$_InitialStateCopyWith<$Res> {
  factory _$$_InitialStateCopyWith(
          _$_InitialState value, $Res Function(_$_InitialState) then) =
      __$$_InitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialStateCopyWithImpl<$Res>
    extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_InitialStateCopyWith<$Res> {
  __$$_InitialStateCopyWithImpl(
      _$_InitialState _value, $Res Function(_$_InitialState) _then)
      : super(_value, (v) => _then(v as _$_InitialState));

  @override
  _$_InitialState get _value => super._value as _$_InitialState;
}

/// @nodoc

class _$_InitialState implements _InitialState {
  const _$_InitialState();

  @override
  String toString() {
    return 'DrawingState.initialState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return initialState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return initialState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return initialState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return initialState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState(this);
    }
    return orElse();
  }
}

abstract class _InitialState implements DrawingState {
  const factory _InitialState() = _$_InitialState;
}

/// @nodoc
abstract class _$$_PenStateCopyWith<$Res> {
  factory _$$_PenStateCopyWith(
          _$_PenState value, $Res Function(_$_PenState) then) =
      __$$_PenStateCopyWithImpl<$Res>;
  $Res call({PenEntity pen});
}

/// @nodoc
class __$$_PenStateCopyWithImpl<$Res> extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_PenStateCopyWith<$Res> {
  __$$_PenStateCopyWithImpl(
      _$_PenState _value, $Res Function(_$_PenState) _then)
      : super(_value, (v) => _then(v as _$_PenState));

  @override
  _$_PenState get _value => super._value as _$_PenState;

  @override
  $Res call({
    Object? pen = freezed,
  }) {
    return _then(_$_PenState(
      pen: pen == freezed
          ? _value.pen
          : pen // ignore: cast_nullable_to_non_nullable
              as PenEntity,
    ));
  }
}

/// @nodoc

class _$_PenState implements _PenState {
  const _$_PenState({required this.pen});

  @override
  final PenEntity pen;

  @override
  String toString() {
    return 'DrawingState.penState(pen: $pen)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PenState &&
            const DeepCollectionEquality().equals(other.pen, pen));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(pen));

  @JsonKey(ignore: true)
  @override
  _$$_PenStateCopyWith<_$_PenState> get copyWith =>
      __$$_PenStateCopyWithImpl<_$_PenState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return penState(pen);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return penState?.call(pen);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (penState != null) {
      return penState(pen);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return penState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return penState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (penState != null) {
      return penState(this);
    }
    return orElse();
  }
}

abstract class _PenState implements DrawingState {
  const factory _PenState({required final PenEntity pen}) = _$_PenState;

  PenEntity get pen => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_PenStateCopyWith<_$_PenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_HighlighterStateCopyWith<$Res> {
  factory _$$_HighlighterStateCopyWith(
          _$_HighlighterState value, $Res Function(_$_HighlighterState) then) =
      __$$_HighlighterStateCopyWithImpl<$Res>;
  $Res call(
      {bool showRuler,
      List<Color> colors,
      int curretColorIdx,
      bool useStylus,
      double width});
}

/// @nodoc
class __$$_HighlighterStateCopyWithImpl<$Res>
    extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_HighlighterStateCopyWith<$Res> {
  __$$_HighlighterStateCopyWithImpl(
      _$_HighlighterState _value, $Res Function(_$_HighlighterState) _then)
      : super(_value, (v) => _then(v as _$_HighlighterState));

  @override
  _$_HighlighterState get _value => super._value as _$_HighlighterState;

  @override
  $Res call({
    Object? showRuler = freezed,
    Object? colors = freezed,
    Object? curretColorIdx = freezed,
    Object? useStylus = freezed,
    Object? width = freezed,
  }) {
    return _then(_$_HighlighterState(
      showRuler: showRuler == freezed
          ? _value.showRuler
          : showRuler // ignore: cast_nullable_to_non_nullable
              as bool,
      colors: colors == freezed
          ? _value._colors
          : colors // ignore: cast_nullable_to_non_nullable
              as List<Color>,
      curretColorIdx: curretColorIdx == freezed
          ? _value.curretColorIdx
          : curretColorIdx // ignore: cast_nullable_to_non_nullable
              as int,
      useStylus: useStylus == freezed
          ? _value.useStylus
          : useStylus // ignore: cast_nullable_to_non_nullable
              as bool,
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_HighlighterState implements _HighlighterState {
  const _$_HighlighterState(
      {required this.showRuler,
      required final List<Color> colors,
      required this.curretColorIdx,
      required this.useStylus,
      required this.width})
      : _colors = colors;

  @override
  final bool showRuler;
  final List<Color> _colors;
  @override
  List<Color> get colors {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_colors);
  }

  @override
  final int curretColorIdx;
  @override
  final bool useStylus;
  @override
  final double width;

  @override
  String toString() {
    return 'DrawingState.highlighterState(showRuler: $showRuler, colors: $colors, curretColorIdx: $curretColorIdx, useStylus: $useStylus, width: $width)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_HighlighterState &&
            const DeepCollectionEquality().equals(other.showRuler, showRuler) &&
            const DeepCollectionEquality().equals(other._colors, _colors) &&
            const DeepCollectionEquality()
                .equals(other.curretColorIdx, curretColorIdx) &&
            const DeepCollectionEquality().equals(other.useStylus, useStylus) &&
            const DeepCollectionEquality().equals(other.width, width));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(showRuler),
      const DeepCollectionEquality().hash(_colors),
      const DeepCollectionEquality().hash(curretColorIdx),
      const DeepCollectionEquality().hash(useStylus),
      const DeepCollectionEquality().hash(width));

  @JsonKey(ignore: true)
  @override
  _$$_HighlighterStateCopyWith<_$_HighlighterState> get copyWith =>
      __$$_HighlighterStateCopyWithImpl<_$_HighlighterState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return highlighterState(
        showRuler, colors, curretColorIdx, useStylus, width);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return highlighterState?.call(
        showRuler, colors, curretColorIdx, useStylus, width);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (highlighterState != null) {
      return highlighterState(
          showRuler, colors, curretColorIdx, useStylus, width);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return highlighterState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return highlighterState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (highlighterState != null) {
      return highlighterState(this);
    }
    return orElse();
  }
}

abstract class _HighlighterState implements DrawingState {
  const factory _HighlighterState(
      {required final bool showRuler,
      required final List<Color> colors,
      required final int curretColorIdx,
      required final bool useStylus,
      required final double width}) = _$_HighlighterState;

  bool get showRuler => throw _privateConstructorUsedError;
  List<Color> get colors => throw _privateConstructorUsedError;
  int get curretColorIdx => throw _privateConstructorUsedError;
  bool get useStylus => throw _privateConstructorUsedError;
  double get width => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_HighlighterStateCopyWith<_$_HighlighterState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EraserStateCopyWith<$Res> {
  factory _$$_EraserStateCopyWith(
          _$_EraserState value, $Res Function(_$_EraserState) then) =
      __$$_EraserStateCopyWithImpl<$Res>;
  $Res call({bool isPartial, bool width});
}

/// @nodoc
class __$$_EraserStateCopyWithImpl<$Res>
    extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_EraserStateCopyWith<$Res> {
  __$$_EraserStateCopyWithImpl(
      _$_EraserState _value, $Res Function(_$_EraserState) _then)
      : super(_value, (v) => _then(v as _$_EraserState));

  @override
  _$_EraserState get _value => super._value as _$_EraserState;

  @override
  $Res call({
    Object? isPartial = freezed,
    Object? width = freezed,
  }) {
    return _then(_$_EraserState(
      isPartial: isPartial == freezed
          ? _value.isPartial
          : isPartial // ignore: cast_nullable_to_non_nullable
              as bool,
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_EraserState implements _EraserState {
  const _$_EraserState({required this.isPartial, required this.width});

  @override
  final bool isPartial;
  @override
  final bool width;

  @override
  String toString() {
    return 'DrawingState.eraserState(isPartial: $isPartial, width: $width)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EraserState &&
            const DeepCollectionEquality().equals(other.isPartial, isPartial) &&
            const DeepCollectionEquality().equals(other.width, width));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isPartial),
      const DeepCollectionEquality().hash(width));

  @JsonKey(ignore: true)
  @override
  _$$_EraserStateCopyWith<_$_EraserState> get copyWith =>
      __$$_EraserStateCopyWithImpl<_$_EraserState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return eraserState(isPartial, width);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return eraserState?.call(isPartial, width);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (eraserState != null) {
      return eraserState(isPartial, width);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return eraserState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return eraserState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (eraserState != null) {
      return eraserState(this);
    }
    return orElse();
  }
}

abstract class _EraserState implements DrawingState {
  const factory _EraserState(
      {required final bool isPartial,
      required final bool width}) = _$_EraserState;

  bool get isPartial => throw _privateConstructorUsedError;
  bool get width => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_EraserStateCopyWith<_$_EraserState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PanStateCopyWith<$Res> {
  factory _$$_PanStateCopyWith(
          _$_PanState value, $Res Function(_$_PanState) then) =
      __$$_PanStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PanStateCopyWithImpl<$Res> extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_PanStateCopyWith<$Res> {
  __$$_PanStateCopyWithImpl(
      _$_PanState _value, $Res Function(_$_PanState) _then)
      : super(_value, (v) => _then(v as _$_PanState));

  @override
  _$_PanState get _value => super._value as _$_PanState;
}

/// @nodoc

class _$_PanState implements _PanState {
  const _$_PanState();

  @override
  String toString() {
    return 'DrawingState.panState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PanState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return panState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return panState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (panState != null) {
      return panState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return panState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return panState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (panState != null) {
      return panState(this);
    }
    return orElse();
  }
}

abstract class _PanState implements DrawingState {
  const factory _PanState() = _$_PanState;
}

/// @nodoc
abstract class _$$_PictureStateCopyWith<$Res> {
  factory _$$_PictureStateCopyWith(
          _$_PictureState value, $Res Function(_$_PictureState) then) =
      __$$_PictureStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PictureStateCopyWithImpl<$Res>
    extends _$DrawingStateCopyWithImpl<$Res>
    implements _$$_PictureStateCopyWith<$Res> {
  __$$_PictureStateCopyWithImpl(
      _$_PictureState _value, $Res Function(_$_PictureState) _then)
      : super(_value, (v) => _then(v as _$_PictureState));

  @override
  _$_PictureState get _value => super._value as _$_PictureState;
}

/// @nodoc

class _$_PictureState implements _PictureState {
  const _$_PictureState();

  @override
  String toString() {
    return 'DrawingState.pictureState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PictureState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function(PenEntity pen) penState,
    required TResult Function(bool showRuler, List<Color> colors,
            int curretColorIdx, bool useStylus, double width)
        highlighterState,
    required TResult Function(bool isPartial, bool width) eraserState,
    required TResult Function() panState,
    required TResult Function() pictureState,
  }) {
    return pictureState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
  }) {
    return pictureState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function(PenEntity pen)? penState,
    TResult Function(bool showRuler, List<Color> colors, int curretColorIdx,
            bool useStylus, double width)?
        highlighterState,
    TResult Function(bool isPartial, bool width)? eraserState,
    TResult Function()? panState,
    TResult Function()? pictureState,
    required TResult orElse(),
  }) {
    if (pictureState != null) {
      return pictureState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_PenState value) penState,
    required TResult Function(_HighlighterState value) highlighterState,
    required TResult Function(_EraserState value) eraserState,
    required TResult Function(_PanState value) panState,
    required TResult Function(_PictureState value) pictureState,
  }) {
    return pictureState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
  }) {
    return pictureState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_PenState value)? penState,
    TResult Function(_HighlighterState value)? highlighterState,
    TResult Function(_EraserState value)? eraserState,
    TResult Function(_PanState value)? panState,
    TResult Function(_PictureState value)? pictureState,
    required TResult orElse(),
  }) {
    if (pictureState != null) {
      return pictureState(this);
    }
    return orElse();
  }
}

abstract class _PictureState implements DrawingState {
  const factory _PictureState() = _$_PictureState;
}
